package com.nyeggen.cryptid.b2;

import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.Map;

import com.backblaze.b2.client.contentSources.B2ContentSource;
import com.backblaze.b2.client.contentSources.B2ContentTypes;
import com.backblaze.b2.client.contentSources.B2FileContentSource;
import com.backblaze.b2.client.structures.B2UploadFileRequest;
import com.nyeggen.cryptid.util.Hasher;
import com.nyeggen.cryptid.util.KeyfileCrypter;

//These are what's actually generated by scanning the local filesystem
public class LocalRecord implements Comparable<LocalRecord> {
	private Path path;
	private Path cryptPath = null;
	
	private NamefileMetadata nameAndTimestamp;
	private IntrinsicMetadata hashAndSize;
	
	public long getSize() { return hashAndSize.getSize(); }
	public byte[] getHash() { return hashAndSize.getHash(); }	
	public String getLocalName() { return nameAndTimestamp.localName; }
	public long getTimestamp() { return nameAndTimestamp.timestamp; }

	@Override
	public int compareTo(LocalRecord o) {
		return Long.compare(getSize(), o.getSize());
	}
	
	public byte[] populateHash() throws IOException {
		if(hashAndSize.getHash() == null) {
			hashAndSize.setHash(Hasher.hash(path));			
		}
		return hashAndSize.getHash();
	}
	
	public LocalRecord(Path p) throws IOException {
		this.path = p;
		//Will be resolved as relative, which is what we want
		final String name = p.toString();
		final long timestamp = Files.getLastModifiedTime(p).toMillis();
		final long size = Files.size(p);
		
		//Hash is initially unset
		this.hashAndSize = new IntrinsicMetadata(null, size);
		this.nameAndTimestamp = new NamefileMetadata(name, timestamp, hashAndSize.getRemoteName());
	}
	
	public void deleteTempCryptFile() throws IOException {
		if(cryptPath != null) Files.delete(cryptPath);
	}
	
	//This is fairly expensive due to calculating the hash, and subsequently
	//the encryption of the stream
	public B2UploadFileRequest uploadForBody(KeyfileCrypter crypt, String bucketId) throws IOException {
		populateHash(); //Necessary so remote file has hash
		final Map<String, String> intrinsicMD = hashAndSize.mdForUpload(crypt);

		this.cryptPath = crypt.encryptFileToTemp(path);
		final B2ContentSource contentSource = B2FileContentSource.build(this.cryptPath.toFile());
		
		final B2UploadFileRequest body = B2UploadFileRequest.builder(
				bucketId,
				hashAndSize.getRemoteName(), 
				B2ContentTypes.APPLICATION_OCTET, 
				contentSource)
					.setCustomFields(intrinsicMD)
					.build();

		return body;
	}
	
	//If using for rename, we also need to delete the previous namefile
	public B2UploadFileRequest uploadForName(KeyfileCrypter crypt, String bucketId) throws IOException {
		return nameAndTimestamp.toUpload(crypt, bucketId);
	}
}
